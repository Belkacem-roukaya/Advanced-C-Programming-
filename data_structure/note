## 1ï¸âƒ£ Quâ€™est-ce quâ€™une `union` en C ?

Une **union** est un type de donnÃ©e qui peut **contenir plusieurs types diffÃ©rents**,
ğŸ‘‰ **mais un seul Ã  la fois**.

ğŸ‘‰ **Tous les membres partagent la mÃªme zone mÃ©moire**.

```c
union Data {
    uint8_t  u8;
    uint16_t u16;
    uint32_t u32;
};
```
## 2ï¸âƒ£ â€œThe members share the same memory locationâ€

Cela veut dire que :

* `u8`, `u16` et `u32` utilisent **exactement la mÃªme adresse mÃ©moire**
* quand tu Ã©cris dans un membre, tu **Ã©crases les autres**

### Exemple

```c
union Data d;

d.u32 = 0x12345678;
d.u8  = 0xAA;   // Ã©crase le dÃ©but de la mÃ©moire
```

â¡ï¸ AprÃ¨s avoir Ã©crit `u8`, la valeur de `u32` **nâ€™est plus valide**.


## 3ï¸âƒ£ â€œUnion is capable of holding different types of data at different timesâ€

âœ”ï¸ Exact
Une union peut contenir :

* **un int maintenant**
* **un float plus tard**
* **un tableau aprÃ¨s**

âŒ Mais **pas plusieurs en mÃªme temps**.


## 4ï¸âƒ£ â€œUnions are as large as their largest memberâ€

TrÃ¨s important ğŸ’¡

### Exemple

```c
union Example {
    uint8_t  a;   // 1 byte
    uint16_t b;   // 2 bytes
    uint32_t c;   // 4 bytes
};
```

â¡ï¸ Taille de la union = **4 bytes**

MÃªme si tu utilises seulement `a`.


## 5ï¸âƒ£ Lâ€™analogie des livres ğŸ“š (trÃ¨s bonne)

Tu as Ã©crit :

> *union are like a stack of books where only one can be read at a time*

ğŸ‘‰ Parfait ğŸ‘Œ
Voici la correspondance :

| Analogie                  | Union                 |
| ------------------------- | --------------------- |
| Pile de livres            | Zone mÃ©moire          |
| Un livre lu               | Un seul membre valide |
| Changer de livre          | Ã‰craser la mÃ©moire    |
| Taille du plus gros livre | Taille de la union    |


### Exemple avec les livres

```c
union Book {
    int    math;
    float  physics;
    char   literature[20];
};
```

* `literature` est le **plus gros livre**
* la union aura la taille de `literature`
* si tu Ã©cris `math`, puis `physics` â†’ **math est perdu**


## 6ï¸âƒ£ â€œBefore a book is checked out, it must be loaded into the unionâ€

Ã‡a veut dire :

ğŸ‘‰ Avant dâ€™utiliser un membre, **tu dois Ã©crire dedans**

âŒ Tu ne peux PAS lire un membre qui nâ€™a pas Ã©tÃ© Ã©crit avant.

### âŒ Mauvais

```c
union Data d;
printf("%d", d.u16); // valeur inconnue
```

### âœ… Correct

```c
d.u16 = 100;
printf("%d", d.u16);
```

## 7ï¸âƒ£ â€œOnly one book is valid within the union at a timeâ€

âœ”ï¸ Exact

Si tu fais :

```c
d.u32 = 500;
d.u8  = 10;
```

â¡ï¸ **Seul `u8` est valide maintenant**
â¡ï¸ `u32` contient des donnÃ©es corrompues


## 8ï¸âƒ£ Exemple concret STM32 ğŸš€

### Cas rÃ©el : donnÃ©es reÃ§ues par UART

Tu reÃ§ois 4 octets, mais tu veux parfois les lire comme :

* `uint32_t`
* `float`

```c
union UART_Data {
    uint8_t  bytes[4];
    uint32_t value;
    float    fvalue;
};
```

```c
union UART_Data rx;

rx.bytes[0] = 0x00;
rx.bytes[1] = 0x00;
rx.bytes[2] = 0x80;
rx.bytes[3] = 0x3F;

float x = rx.fvalue;  // x = 1.0
```

â¡ï¸ MÃªme mÃ©moire
â¡ï¸ InterprÃ©tation diffÃ©rente


## 9ï¸âƒ£ Union + struct (trÃ¨s utilisÃ©)

```c
typedef union {
    uint8_t all;
    struct {
        uint8_t bit0 : 1;
        uint8_t bit1 : 1;
        uint8_t bit2 : 1;
        uint8_t bit3 : 1;
        uint8_t bit4 : 1;
        uint8_t bit5 : 1;
        uint8_t bit6 : 1;
        uint8_t bit7 : 1;
    } bits;
} Register8_t;
```

```c
Register8_t reg;

reg.all = 0x05;
reg.bits.bit0 = 1;
```

ğŸ”¥ TrÃ¨s courant en STM32 pour les registres


## ğŸ”Ÿ RÃ©sumÃ© simple ğŸ§ 

* `union` = **une seule mÃ©moire**
* plusieurs types possibles
* **un seul valide Ã  la fois**
* taille = **plus grand membre**
* idÃ©ale pour :

  * protocoles
  * registres
  * Ã©conomie mÃ©moire
  * embarquÃ© STM32

######

# âœ… RÃˆGLE Dâ€™OR (Ã  retenir)

ğŸ‘‰ **STRUCT** :
â¡ï¸ quand **TOUTES les donnÃ©es existent en mÃªme temps**

ğŸ‘‰ **UNION** :
â¡ï¸ quand **UNE SEULE donnÃ©e est valide Ã  la fois**

---

# 1ï¸âƒ£ Exemple clair avec la vraie vie

## STRUCT = sac Ã  dos ğŸ’

Tu peux mettre **tous les objets en mÃªme temps**

## UNION = clÃ© USB ğŸ’¾

Tu peux stocker **un seul fichier Ã  la fois**

---

# 2ï¸âƒ£ Exemple simple (pas STM32)

## ğŸŸ¢ STRUCT (tout existe en mÃªme temps)

```c
struct Person {
    uint8_t age;
    float   taille;
    char    sexe;
};
```

âœ”ï¸ Ã¢ge + taille + sexe existent ensemble
âŒ impossible avec une union

---

## ğŸ”µ UNION (une seule info Ã  la fois)

```c
union Mesure {
    int   temperature;
    float pression;
};
```

âœ”ï¸ soit tempÃ©rature
âœ”ï¸ soit pression
âŒ jamais les deux en mÃªme temps

---

# 3ï¸âƒ£ STM32 â€“ Cas rÃ©el nÂ°1 : capteur

## âŒ Mauvais choix (union)

```c
union Capteur {
    uint16_t temperature;
    uint16_t humidite;
};
```

âŒ ProblÃ¨me : tu perds une valeur

---

## âœ… Bon choix (struct)

```c
struct Capteur {
    uint16_t temperature;
    uint16_t humidite;
};
```

âœ”ï¸ les deux mesures existent en mÃªme temps

---

# 4ï¸âƒ£ STM32 â€“ Cas rÃ©el nÂ°2 : protocole UART

Tu reÃ§ois **4 octets**, mais tu peux les interprÃ©ter de plusieurs faÃ§ons.

## âœ… Bon choix : UNION

```c
union UART_Data {
    uint8_t  bytes[4];
    uint32_t value;
    float    fvalue;
};
```

```c
rx.bytes[0] = 0x00;
rx.bytes[1] = 0x00;
rx.bytes[2] = 0x80;
rx.bytes[3] = 0x3F;

float x = rx.fvalue; // 1.0
```

âœ”ï¸ mÃªme mÃ©moire
âœ”ï¸ interprÃ©tation diffÃ©rente
âŒ struct gaspillerait la mÃ©moire

---

# 5ï¸âƒ£ STM32 â€“ Registre matÃ©riel

Un registre peut Ãªtre vu :

* comme un entier
* comme des bits

## âœ… UNION + STRUCT (le plus puissant)

```c
typedef union {
    uint32_t ALL;
    struct {
        uint32_t PIN0 : 1;
        uint32_t PIN1 : 1;
        uint32_t PIN2 : 1;
        uint32_t PIN3 : 1;
        uint32_t PIN4 : 1;
        uint32_t PIN5 : 1;
        uint32_t PIN6 : 1;
        uint32_t PIN7 : 1;
        uint32_t RESERVED : 24;
    } BITS;
} GPIO_ODR_t;
```

```c
GPIO_ODR_t odr;

odr.ALL = 0x20;       // PA5 = 1
odr.BITS.PIN5 = 0;   // PA5 = 0
```

ğŸ”¥ TrÃ¨s utilisÃ© en STM32

---

# 6ï¸âƒ£ STM32 â€“ Machine dâ€™Ã©tat (state machine)

## âŒ Mauvais choix (struct)

```c
struct State {
    uint8_t IDLE;
    uint8_t RUN;
    uint8_t ERROR;
};
```

---

## âœ… Bon choix (union)

```c
typedef union {
    uint8_t state;
    struct {
        uint8_t IDLE  : 1;
        uint8_t RUN   : 1;
        uint8_t ERROR : 1;
    } bits;
} SystemState_t;
```

âœ”ï¸ un seul Ã©tat actif
âœ”ï¸ mÃ©moire optimisÃ©e

---

# 7ï¸âƒ£ Tableau comparatif FINAL ğŸ§ 

| Situation                       | Choix            |
| ------------------------------- | ---------------- |
| Plusieurs valeurs en mÃªme temps | `struct`         |
| Une seule valeur valide         | `union`          |
| DonnÃ©es indÃ©pendantes           | `struct`         |
| MÃªme donnÃ©e, formats diffÃ©rents | `union`          |
| Registres STM32                 | `union + struct` |
| Capteurs multiples              | `struct`         |
| Protocoles                      | `union`          |

###
ğŸ¯ Le PROBLÃˆME Ã  rÃ©soudre

Sur un PIC 8-bit :

Le rÃ©sultat de lâ€™ADC fait 10 bits

Mais le MCU est 8 bits

Donc le rÃ©sultat est stockÃ© dans DEUX registres :

ADRESH â†’ partie haute

ADRESL â†’ partie basse

ğŸ‘‰ Toi, tu veux une seule variable 16 bits pour utiliser la valeur facilement.

ğŸ§  La SOLUTION : union + struct

On utilise :

struct â†’ pour accÃ©der aux 2 octets sÃ©parÃ©ment

union â†’ pour voir ces 2 octets comme un seul entier 16 bits
1ï¸âƒ£ Pourquoi une union ici ?

ğŸ‘‰ Parce que tous les membres partagent la mÃªme mÃ©moire.

Cela veut dire que :

MÃ©moire (16 bits)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ High â”‚ Low   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


u16ADRead â†’ voit les 16 bits dâ€™un coup

u8ADReadLow et u8ADReadHigh â†’ voient les mÃªmes bits, mais sÃ©parÃ©s

ğŸ”¥ Câ€™est exactement ce quâ€™on veut.

2ï¸âƒ£ Pourquoi un struct Ã  lâ€™intÃ©rieur ?

ğŸ‘‰ Parce que les registres ADC sont sÃ©parÃ©s :

ADRESH â†’ octet haut
ADRESL â†’ octet bas


Donc on a besoin de deux variables distinctes pour les copier.

ğŸ“¥ Chargement des registres ADC
UNION_ADRead.STRUCT_ADReadMembers.u8ADReadHigh = ADRESH;
UNION_ADRead.STRUCT_ADReadMembers.u8ADReadLow  = ADRESL;


ğŸ‘‰ Ici :

Tu copies ADRESH dans lâ€™octet haut

Tu copies ADRESL dans lâ€™octet bas

âš ï¸ TrÃ¨s important : lâ€™ordre compte !

ğŸ§© Ce qui se passe en mÃ©moire (visualisation)

Supposons :

ADRESH = 0x02;
ADRESL = 0xAB;


MÃ©moire de la union :

Adresse basse â†’ u8ADReadLow  = 0xAB
Adresse haute â†’ u8ADReadHigh = 0x02


Donc :

u16ADRead = 0x02AB;


ğŸ‰ RÃ©sultat ADC correct !

âœ… Pourquoi u16ADRead contient la valeur complÃ¨te ?

Parce que :

union â†’ mÃªme mÃ©moire

struct â†’ dÃ©coupe la mÃ©moire

unsigned int â†’ relit la mÃ©moire en 16 bits

ğŸ‘‰ Aucune copie supplÃ©mentaire
ğŸ‘‰ TrÃ¨s rapide
ğŸ‘‰ TrÃ¨s efficace en MCU 8-bit

ğŸŸ¢ Pourquoi câ€™est un BON choix ici ?
Besoin	Solution
ADC sur 2 registres	struct
Valeur complÃ¨te 16 bits	unsigned int
MÃªme mÃ©moire	union
Performance	â­â­â­â­â­
LisibilitÃ©	â­â­â­â­
